# Modules import
import os
import subprocess
import pandas

""" FUNCTIONS & PARAMETERS """
########################################################################################################################
# Parameters:
wkd = "/home/fllobet/RNA-Seq/RNA-Seq_11.1_FLC/"
eq_csv = wkd + "IDs.csv"
workdir: wkd

# Functions:
""" Function 'n_cores' obtains the number of cores of a given machine """
def n_cores():
    grp = subprocess.run(["grep", "^cpu\\scores", "/proc/cpuinfo"],stdout=subprocess.PIPE,stderr=subprocess.PIPE,
        check=True)
    uq = subprocess.run(["uniq"],input=grp.stdout,stdout=subprocess.PIPE,stderr=subprocess.PIPE,
        check=True)
    return int(
        subprocess.run(["awk", "{print $4}"],input=uq.stdout,stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,check=True).stdout.decode("utf-8"))

""" Function 'unique_to_rename' implements a slight modification to the previous function 'files_to_rename' but 
returning only the unique values, hence allowing the merging of BAMs from samples that were divided in multiple 
channels in the sequencer. """
def unique_to_rename(file_in=None,
                     restrictions=[],      # 'restrictions' are any combinations of col-condition.
                    col_out=None):
    # 'restrictions' must be a list as it will be used to extend the arguments list of the python script 'Selector.py'
    sel_args = [wkd + "scripts/interchanger.py", file_in]
    sel_args.extend(restrictions)

    # Selection
    sel = subprocess.run(sel_args,
        stdout=subprocess.PIPE,stderr=subprocess.PIPE,
        check=True)

    # Expansion of the input filenames using the new dataset
    df = pandas.read_csv(sel.stdout.decode("utf-8")[:-1], sep=";")

    # Removal of repeated rows
    df = df.drop_duplicates(subset=[col_out])
    print(df[["Project", col_out]])
    return df[col_out]

def where_conda(c_env, program):
    # Activation of the conda environment within a 'subprocess' shell:
    c_act = subprocess.run(["conda", "activate", c_env], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        check=True)
    # Where is the 'program'?
    return subprocess.run(["which", program], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        check=True).stdout.decode("utf-8")


""" RULES """
########################################################################################################################
rule all:
    input:
        expand("COUNTS/{file_name}.genes.results",  # The doc of RSEM told me what to expect as output <3 <3 <3.
            file_name = unique_to_rename(file_in=eq_csv, col_out="SAMPLE_NAME"))

""" The rule 'sort' will sort the input BAM by coordinate.
    - 'samtools' is installed in the conda environment 'align.yaml' VERSION 1.13 """
rule sort:
    input:
        bm = "ALIGNED_Reads/{file_name}.bam"  # Input BAM file.
    output:
        slg = "ALIGNED_Reads/{file_name}.slog"  # Manually created log of the sorting of the BAM file using 'samtools'.
    threads: n_cores()

    conda:
        "align.yaml"  # The 'align' conda environment will be used as it contains 'samtools' among others.
    shell:
        "./scripts/sort.sh {input.bm} {threads}"

rule index:
    input:
        bm = "ALIGNED_Reads/{file_name}.bam",  # Input BAM file.
        # My artificial  '.slog' is  included to ensure that  indexing is done after the sort
        slg = "ALIGNED_Reads/{file_name}.slog"
    output:
        bi = "ALIGNED_Reads/{file_name}.bam.bai"  # Input index BAI file.
    threads: n_cores()

    conda: "align.yaml"
    shell:
        "./scripts/index.sh {input.bm}"

rule RSEM_index:
    input:
        s11 = "REF_Genome/{genome}.fa",  # De-compressed genome (downloaded and decompressed in 'Read_Mapping.smk')
        a11 = "REF_Genome/{genome}.gtf"  # De-compressed annotations."
    output:
        # A random file generated by the RSEM indexing but NOT the STAR indexing so the old STAR indexing is overridden.
        RS11 = "INDEXED_Genome/{genome}.seq"
    log: "RSEM_indexed_{genome}.RIlog"
    params:
        star = where_conda("align", "STAR"), # The function 'where_conda' is used to locate the executable of STAR
        hang = 75,  # The value of '--sjdboverhang' parameter for STAR's indexing; ReadLength - 1. Mine are 76 nt long.
        gnme = "INDEXED_Genome/{genome}"  # The 'indexed_genome_name' of STAR mus include the directory where gonna be.
    threads: n_cores()

    conda: "align.yaml"
    shell:
        # The arguments structure is given by 'RSEM_indexing.sh'. The location of the indexed genome is given by it too.
        "./RSEM_indexing.sh {inputs.a11} {inputs.s11} {params.gnme} {params.star} {params.hang} {threads}"
        "touch {log}" # The 'artificial' '.RIlog' file is created so 'snakemake' understands the rule hierarchy.

rule RSEM_counts:
    input:
        RS11 = expand("RSEM_indexed_{genome}.RIlog",  # The '.RIlog' to maintain the 'snakemake' hierarchy.
            genome=glob_wildcards("./REF_Genome/{genome}.fa").genome),
        bm = "ALIGNED_Reads/{file_name}.bam"  # Input BAM file.
    output:
        cts = "COUNTS/{file_name}.genes.results" # The doc of RSEM told me what to expect as output <3 <3 <3.
    params:
        gnme = expand("INDEXED_Genome/{genome}",  # The 'indexed_genome_name' of RSEM must include the directory.
            genome=glob_wildcards("./REF_Genome/{genome}.fa").genome),
        strd = "reverse"  # Strandednes of the RNA-Seq experiment protocol. KEY PARAMETER. Used inside the script.
    threads: n_cores()

    conda: "align.yaml"
    shell:
        # The arguments structure is given by 'RSEM_counting.sh'.
        "./RSEM_counting.sh {params.strd} {params.gnme} {input.bm} {threads}"

